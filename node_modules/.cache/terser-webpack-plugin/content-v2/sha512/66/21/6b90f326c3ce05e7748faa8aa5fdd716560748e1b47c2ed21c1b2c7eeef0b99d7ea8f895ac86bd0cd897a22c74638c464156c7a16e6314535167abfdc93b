{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{323:function(t,s,e){\"use strict\";e.r(s);var n=e(10),r=Object(n.a)({},(function(){var t=this,s=t._self._c;return s(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[s(\"h1\",{attrs:{id:\"记录一次gc优化记录\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#记录一次gc优化记录\"}},[t._v(\"#\")]),t._v(\" 记录一次GC优化记录\")]),t._v(\" \"),s(\"p\",[t._v(\"这个图片没有了，这个是在公司做了，用的公司的电脑，记录是回来记录的，没有相关的截图，只能口头记录一下。\")]),t._v(\" \"),s(\"p\",[t._v(\"这个场景呢，是有一个对应的抢书，让后每次抢课都会记录对应的人员信息，这个是用redis进行记录的，\\n他有一个对应的书籍因为买的人过多了，所以导致他的这个对应的redis里面的这个sort set这个键的value就添加了非常多的人员信息\\n，每次管理员查看人员信息的时候都会加载很长时间，跟我这边来的实习生一起检查，才发现每次都会进行yong gc。\\n原因是这个value有点大，几万条数据在里面，然后存储的是他的JSON字符串，每次从redis中取出来的时候都需要进行对应的序列化，成为一个List。\\n这个List呢又涉及到堆的空间分配，每次都创建一个对应的List，就会导致这个空间特别大。就会触发yong gc。\")]),t._v(\" \"),s(\"h2\",{attrs:{id:\"解决\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#解决\"}},[t._v(\"#\")]),t._v(\" 解决\")]),t._v(\" \"),s(\"p\",[t._v(\"我把这个对应的List变量设置成为一个对应的静态变量，每次进行序列化转换的时候直接覆盖之前的空间就行，不涉及到重新分配空间。\\n解决了减少对应的yong gc。但是这里还需要解决的就是这个Redis的这个大key应该要把他进行拆分，或者加本地缓存进行解决，不然每次涉及到网络传输这么大的一个key，开销会非常大，遇到请求多的时候，直接爆炸了。\")])])}),[],!1,null,null,null);s.default=r.exports}}]);","extractedComments":[]}